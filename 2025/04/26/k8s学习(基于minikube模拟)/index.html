

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/tuyi.jpg">
  <link rel="icon" href="/img/tuyi.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="tuyi">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言最近机缘巧合下对于云原生比较感兴趣，本文使用minikube模拟k8s集群，使用kubectl管理集群 环境是Ubuntu22.04 TLS ps:本文转载自https:&#x2F;&#x2F;guangzhengli.com&#x2F;courses&#x2F;kubernetes，只是作为个人学习 准备工作安装docker使用官方安装脚本自动安装: 12curl -fsSL https:&#x2F;&#x2F;test.docker.com -o">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s学习(基于minikube模拟)">
<meta property="og:url" content="https://tuyiisxp.github.io/2025/04/26/k8s%E5%AD%A6%E4%B9%A0(%E5%9F%BA%E4%BA%8Eminikube%E6%A8%A1%E6%8B%9F)/">
<meta property="og:site_name" content="tuyi的小站">
<meta property="og:description" content="前言最近机缘巧合下对于云原生比较感兴趣，本文使用minikube模拟k8s集群，使用kubectl管理集群 环境是Ubuntu22.04 TLS ps:本文转载自https:&#x2F;&#x2F;guangzhengli.com&#x2F;courses&#x2F;kubernetes，只是作为个人学习 准备工作安装docker使用官方安装脚本自动安装: 12curl -fsSL https:&#x2F;&#x2F;test.docker.com -o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/image-20250426232154933.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/nginx_pod.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/pod.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/deployment.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/rollingupdate.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-clusterip-fix-name.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-nodeport-fix-name.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-loadbalancer-fix-name.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/ingress.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/eB3MYd.png">
<meta property="og:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/83ybd4.png">
<meta property="article:published_time" content="2025-04-26T14:10:33.000Z">
<meta property="article:modified_time" content="2025-04-28T11:35:47.751Z">
<meta property="article:author" content="tuyi">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/image-20250426232154933.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>k8s学习(基于minikube模拟) - tuyi的小站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">
<link rel="stylesheet" href="/css/reward.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tuyiisxp.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>tuyi的小站</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="k8s学习(基于minikube模拟)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-26 22:10" pubdate>
          2025年4月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          102 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">k8s学习(基于minikube模拟)</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年4月28日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近机缘巧合下对于云原生比较感兴趣，本文使用<code>minikube</code>模拟k8s集群，使用<code>kubectl</code>管理集群</p>
<p>环境是<code>Ubuntu22.04 TLS</code></p>
<p>ps:本文转载自<a target="_blank" rel="noopener" href="https://guangzhengli.com/courses/kubernetes%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0">https://guangzhengli.com/courses/kubernetes，只是作为个人学习</a></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装<code>docker</code></h2><p>使用官方安装脚本自动安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://test.docker.com -o test-docker.sh<br><span class="hljs-built_in">sudo</span> sh test-docker.sh<br></code></pre></td></tr></table></figure>

<p>由于minikube的docker引擎不能是root权限，所有我们将普通用户加入docker用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure>

<h2 id="安装minikube"><a href="#安装minikube" class="headerlink" title="安装minikube"></a>安装<code>minikube</code></h2><p>我们使用 **<a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/start/?arch=/linux/x86-64/stable/debian+package">Debian 软件包</a>**安装最新版的最新的 minikube <strong>稳定</strong>版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb<br><span class="hljs-built_in">sudo</span> dpkg -i minikube_latest_amd64.deb<br></code></pre></td></tr></table></figure>

<h2 id="启动minikube"><a href="#启动minikube" class="headerlink" title="启动minikube"></a>启动<code>minikube</code></h2><p>我们使用<code>minikube start</code>回启动一个单节点的 Kubernetes 集群</p>
<p><code>minikube start</code>参数解释:</p>
<blockquote>
<p><code>--driver=&lt;driver&gt;</code>：指定使用的驱动程序，如 <code>docker</code>、<code>virtualbox</code>、<code>hyperv</code> 等,不指定会自动识别。</p>
<p><code>--kubernetes-version=&lt;version&gt;</code>：指定 Kubernetes 的版本，不指定会自动识别。</p>
<p><code>--memory=&lt;MB&gt;</code> 和 <code>--cpus=&lt;num&gt;</code>：分配给集群的内存和 CPU 核心数，默认是2200mb和2核。</p>
<p><code>--image-repository=&lt;url&gt;</code>：指定镜像仓库地址，适用于网络受限的环境。建议更换国内节点</p>
<p><code>--container-runtime=&lt;runtime&gt;</code>：选择容器运行时，如 <code>docker</code>、<code>containerd</code> 或 <code>cri-o</code>不指定会自动识别 </p>
<p><code>--extra-config=&lt;component.key=value&gt;</code>：为 Kubernetes 组件设置额外的配置参数。</p>
</blockquote>
<p>使用<code>minikube status</code>查看集群状态</p>
<p><strong>minikube 命令速查</strong></p>
<p><code>minikube stop</code> 不会删除任何数据，只是停止 VM 和 k8s 集群。</p>
<p><code>minikube delete</code> 删除所有 minikube 启动后的数据。</p>
<p><code>minikube ip</code> 查看集群和 docker enginer 运行的 IP 地址。</p>
<p><code>minikube pause</code> 暂停当前的资源和 k8s 集群</p>
<p><code>minikube status</code> 查看当前集群状态</p>
<h2 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h2><p>使用以下命令安装：或者安装<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#install-using-native-package-management">Debian发行版</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span> <span class="hljs-comment">#下载最新版</span><br><span class="hljs-built_in">sudo</span> install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl <span class="hljs-comment">#安装kubectl</span><br></code></pre></td></tr></table></figure>

<p>执行测试，以保障你安装的版本是最新的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl version --client<br></code></pre></td></tr></table></figure>

<p>或者使用如下命令来查看版本的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl version --client --output=yaml<br></code></pre></td></tr></table></figure>

<p>通过获取集群状态的方法，检查是否已恰当地配置了 <code>kubectl</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl cluster-info<br></code></pre></td></tr></table></figure>

<p>如果返回一个 URL，则意味着 kubectl 成功地访问到了你的集群。</p>
<h2 id="注册-docker-hub-账号登录"><a href="#注册-docker-hub-账号登录" class="headerlink" title="注册 docker hub 账号登录"></a>注册 docker hub 账号登录</h2><p>因为默认 minikube 使用的镜像地址是 DockerHub，</p>
<p>所以我们还需要在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">DockerHub</a> 中注册账号，并且使用 login 命令登录账号。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker login</span><br></code></pre></td></tr></table></figure>

<p>我这里采用aliyun的镜像托管平替</p>
<h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><p>我们的旅程从一段代码开始。新建一个 <code>main.go</code> 文件，复制下面的代码到文件中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	io.WriteString(w, <span class="hljs-string">&quot;[v1] Hello, Kubernetes!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是一串用 <a target="_blank" rel="noopener" href="https://go.dev/">Go</a> 写的代码，代码逻辑非常的简单，首先启动 HTTP 服务器，监听 <code>3000</code> 端口，当访问路由 <code>/</code>的时候 返回字符串 <code>[v1] Hello, Kubernetes!</code>。</p>
<p>在以前，如果你想将这段代码运行起来并测试一下。你首先需要懂得如何下载 golang 的安装包进行安装，接着需要懂得 <code>golang module</code> 的基本使用，最后还需要了解 golang 的编译和运行命令，才能将该代码运行起来。甚至在过程中，可能会因为环境变量问题、操作系统问题、处理器架构等问题导致编译或运行失败。</p>
<p>但是通过 Container (容器) 技术，只需要上面的代码，附带着对应的容器 <code>Dockerfile</code> 文件，那么你就不需要 golang 的任何知识，也能将代码顺利运行起来。</p>
<blockquote>
<p>Container (容器) 是一种沙盒技术。它是基于 Linux 中 Namespace &#x2F; Cgroups &#x2F; chroot 等技术结合而成，更多技术细节可以参看这个视频 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8fi7uSYlOdc">如何自己实现一个容器</a>。</p>
</blockquote>
<p>下面就是 Go 代码对应的 <code>Dockerfile</code>，简单的方案是直接使用 golang 的 alpine 镜像来打包，但是因为我们后续练习需要频繁的推送镜像到 DockerHub 和拉取镜像到 k8s 集群中，为了优化网络速度，我们选择先在 <code>golang:1.16-buster</code> 中将上述 Go 代码编译成二进制文件，再将二进制文件复制到 <code>base-debian10</code> 镜像中运行 (Dockerfile 不理解没有关系，不影响后续教程学习)。</p>
<p>这样我们可以将 300MB 大小的镜像变成只有 20MB 的镜像，甚至压缩上传到 DockerHub 后大小只有 10MB！</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span>-buster AS builder<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /src</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /src</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /src</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go <span class="hljs-built_in">env</span> -w GO111MODULE=auto</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o main .</span><br><br><span class="hljs-keyword">FROM</span> gcr.io/distroless/base-debian10<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /src/main /main</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/main&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<p>需要注意 <code>main.go</code> 文件需要和 <code>Dockerfile</code> 文件在同一个目录下，执行下方 <code>docker build</code> 命令，第一次需要耐心等待拉取基础镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build . -t hellok8s:v1<br>docker run -p 3000:3000 --name hellok8s -d hellok8s:v1<br></code></pre></td></tr></table></figure>

<p>可以看到</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/image-20250426232154933.png" srcset="/img/loading.gif" lazyload alt="image-20250426232154933"></p>
<p>ps:使用<code>minihube ip</code>给出的ip和实际上的ip不一样，因为 Minikube 在本地创建了一个独立的虚拟化环境（如虚拟机或容器），该环境拥有自己的网络接口和 IP 地址,这种设计使得 Minikube 集群与主机系统在网络上相互隔离，从而避免了潜在的端口冲突和安全问题。</p>
<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>如果在生产环境中运行的都是独立的单体服务，那么 Container (容器) 也就够用了，但是在实际的生产环境中，维护着大规模的集群和各种不同的服务，服务之间往往存在着各种各样的关系。而这些关系的处理，才是手动管理最困难的地方。</p>
<p><strong>Pod</strong> 是我们将要创建的第一个 k8s 资源，也是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。在了解 <code>pod</code> 和 <code>container</code> 的区别之前，我们可以先创建一个简单的 pod 试试，</p>
<p>我们先把刚刚的镜像上传到<code>aliyun</code>，我们编写一个yaml来：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># hellok8s.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v1</span><br>  <span class="hljs-attr">imagePullSecrets:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>kind</code> 表示我们要创建的资源是 <code>Pod</code> 类型， <code>metadata.name</code> 表示要创建的 pod 的名字，这个名字需要是唯一的。 <code>spec.containers</code> 表示要运行的容器的名称和镜像地址。</p>
<p>我们运行第一条 k8s 命令 <code>kubectl apply -f hellok8s.yaml</code> 命令来创建 <code>hellok8s</code> Pod。</p>
<p>我们使用<code>kubectl get pods</code>来查看pod状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pods<br>NAME           READY   STATUS             RESTARTS   AGE<br>hellok8s-pod   0/1     running   0          51s<br></code></pre></td></tr></table></figure>

<p>我们使用<code>kubectl port-forward hellok8s-pod 4000:3000</code>将 镜像的<code>3000</code>端口映射到本机的 <code>4000</code> 端口</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">curl http:<span class="hljs-comment">//127.0.0.1:4000</span><br><span class="hljs-string">[v1]</span> Hello, Kubernetes!<br></code></pre></td></tr></table></figure>

<h2 id="Pod-与-Container-的不同"><a href="#Pod-与-Container-的不同" class="headerlink" title="Pod 与 Container 的不同"></a>Pod 与 Container 的不同</h2><p>回到 <code>pod</code> 和 <code>container</code> 的区别，我们会发现刚刚创建出来的资源如下图所示，在最内层是我们的服务 <code>hellok8s</code>，运行在 <code>container</code> 容器当中， <code>container</code> (容器) 的本质是进程，而 <code>pod</code> 是管理这一组进程的资源。</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/nginx_pod.png" srcset="/img/loading.gif" lazyload alt="nginx_pod"></p>
<p>所以自然 <code>pod</code> 可以管理多个 <code>container</code>，在某些场景例如服务之间需要文件交换(日志收集)，本地网络通信需求(使用 localhost 或者 Socket 文件进行本地通信)，在这些场景中使用 <code>pod</code> 管理多个 <code>container</code> 就非常的推荐。而这，也是 k8s 如何处理服务之间复杂关系的第一个例子，如下图所示：</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/pod.png" srcset="/img/loading.gif" lazyload alt="pod"></p>
<h2 id="Pod-其它命令"><a href="#Pod-其它命令" class="headerlink" title="Pod 其它命令"></a>Pod 其它命令</h2><p>我们可以通过 <code>logs</code> 或者 <code>logs -f</code> 命令查看 pod 日志，可以通过 <code>exec -it</code> 进入 pod 或者调用容器命令，通过 <code>delete pod</code> 或者 <code>delete -f hellok8s.yaml</code> 的方式删除 pod 资源。这里可以看到 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/">kubectl 所有命令</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl logs --follow hellok8s<br>                              <br>kubectl exec hellok8s -- ls<br><br>kubectl delete pod hellok8s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod <span class="hljs-string">&quot;hellok8s&quot;</span> deleted</span><br><br>kubectl delete -f hellok8s.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod <span class="hljs-string">&quot;hellok8s&quot;</span> deleted</span><br></code></pre></td></tr></table></figure>

<p>相应的命令如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f hellok8s.yaml<br><br>kubectl get pods<br><br>kubectl port-forward hellok8s 3000:3000<br></code></pre></td></tr></table></figure>

<p>关于启动失败</p>
<p>如果查看Pod的状态为 ErrImagePull 或者 ImagePullBackOff</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME       READY   STATUS             RESTARTS   AGE<br>hellok8s   0/1     ImagePullBackOff   0          22m<br></code></pre></td></tr></table></figure>

<p>如果使用的是docker-hub 尝试切换为当前环境的docker-env, 删除pod, 然后重新构建镜像即可</p>
<ul>
<li>官方文档: <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/pushing/">Pushing directly to the in-cluster Docker daemon (docker-env)</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">eval $(minikube docker-env)<br></code></pre></td></tr></table></figure>

<p>如果使用的是三方镜像托管，再检查你的<code>imagePullSecrets</code>字段有没有错误</p>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>在生产环境中，我们基本上不会直接管理 pod，我们需要 <code>kubernetes</code> 来帮助我们来完成一些自动化操作，例如自动扩容或者自动升级版本。可以想象在生产环境中，我们手动部署了 10 个 <code>hellok8s:v1</code> 的 pod，这个时候我们需要升级成 <code>hellok8s:v2</code> 版本，我们难道需要一个一个的将 <code>hellok8s:v1</code> 的 pod 手动升级吗？</p>
<p>这个时候就需要我们来看 <code>kubeates</code> 的另外一个资源 <code>deployment</code>，来帮助我们管理 pod</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>首先可以创建一个 <code>deployment.yaml</code> 的文件。来管理 <code>hellok8s</code> pod。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v1</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>kind</code> 表示我们要创建的资源是 <code>deployment</code> 类型， <code>metadata.name</code> 表示要创建的 deployment 的名字，这个名字需要是<strong>唯一</strong>的。</p>
<p>在 <code>spec</code> 里面表示，首先 <code>replicas</code> 表示的是部署的 pod 副本数量，<code>selector</code> 里面表示的是 <code>deployment</code> 资源和 <code>pod</code> 资源关联的方式，这里表示 <code>deployment</code> 会管理 (selector) 所有 <code>labels=hellok8s</code> 的 pod。</p>
<p><code>template</code> 的内容是用来定义 <code>pod</code> 资源的，你会发现和Hellok8s Pod 资源的定义是差不多的，唯一的区别是我们需要加上 <code>metadata.labels</code> 来和上面的 <code>selector.matchLabels</code> 对应起来。来表明 pod 是被 deployment 管理，不用在<code>template</code> 里面加上 <code>metadata.name</code> 是因为 deployment 会主动为我们创建 pod 的唯一<code>name</code>。</p>
<p>接下来输入下面的命令，可以创建 <code>deployment</code> 资源。通过 <code>get</code> 和 <code>delete pod</code> 命令，我们会初步感受 deployment 的魅力。<strong>每次创建的 pod 名称都会变化，某些命令记得替换成你的 pod 的名称</strong></p>
<p>当手动删除一个 <code>pod</code> 资源后，deployment 会自动创建一个新的 <code>pod</code>，这和我们之前手动创建 pod 资源有本质的区别！这代表着当生产环境管理着成千上万个 pod 时，我们不需要关心具体的情况，只需要维护好这份 <code>deployment.yaml</code> 文件的资源定义即可</p>
<p>当我们想要将 <code>hellok8s:v1</code> 的资源扩容到 3 个副本时，只需要将 <code>replicas</code> 的值设置成 3，接着重新输入 <code>kubectl apply -f deployment.yaml</code> 即可</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v1</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>

<p>可以在 <code>kubectl apply</code> 之前通过新建窗口执行 <code>kubectl get pods --watch</code> 命令来观察 pod 启动和删除的记录，想要减少副本数时也很简单，你可以尝试将副本数随意增大或者缩小，再通过 <code>watch</code> 来观察它的状态</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/deployment.png" srcset="/img/loading.gif" lazyload alt="deployment"></p>
<h2 id="升级版本"><a href="#升级版本" class="headerlink" title="升级版本"></a>升级版本</h2><p>我们接下来尝试将所有 <code>v1</code> 版本的 <code>pod</code> 升级到 <code>v2</code> 版本。首先我们需要构建一份 <code>hellok8s:v2</code> 的版本镜像。唯一的区别就是字符串替换成了 <code>[v2] Hello, Kubernetes!</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	io.WriteString(w, <span class="hljs-string">&quot;[v2] Hello, Kubernetes!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构建好镜像上传到aliyun，改变deployment的镜像为v2</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v2</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br><br></code></pre></td></tr></table></figure>

<p>应用这个deployment，使用这个命令<code>kubectl describe pod id</code>看到镜像是v2版本的，</p>
<p>使用<code>kubectl port-forward hellok8s-deployment-7b46d8bd86-2v9g4 4000:3000</code></p>
<p>看到是输出<code>[v2] Hello, Kubernetes!</code></p>
<h2 id="Rolling-Update-滚动更新"><a href="#Rolling-Update-滚动更新" class="headerlink" title="Rolling Update(滚动更新)"></a>Rolling Update(滚动更新)</h2><p>如果我们在生产环境上，管理着多个副本的 <code>hellok8s:v1</code> 版本的 pod，我们需要更新到 <code>v2</code> 的版本，像上面那样的部署方式是可以的，但是也会带来一个问题，就是所有的副本在同一时间更新，这会导致我们 <code>hellok8s</code> 服务在短时间内是不可用的，因为所有 pod 都在升级到 <code>v2</code> 版本的过程中，需要等待某个 pod 升级完成后才能提供服务。</p>
<p>这个时候我们就需要滚动更新 (rolling update)，在保证新版本 <code>v2</code> 的 pod 还没有 <code>ready</code> 之前，先不删除 <code>v1</code> 版本的 pod。</p>
<p>在 deployment 的资源定义中, <code>spec.strategy.type</code> 有两种选择:</p>
<ul>
<li><strong>RollingUpdate:</strong> 逐渐增加新版本的 pod，逐渐减少旧版本的 pod。</li>
<li><strong>Recreate:</strong> 在新版本的 pod 增加前，先将所有旧版本 pod 删除。</li>
</ul>
<p>大多数情况下我们会采用滚动更新 (RollingUpdate) 的方式，滚动更新又可以通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 字段来控制升级 pod 的速率，具体可以详细看<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">官网定义</a>。：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-surge"><strong>maxSurge:</strong></a> 最大峰值，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-unavailable,"><strong>maxUnavailable:</strong></a> 最大不可用，用来指定更新过程中不可用的 Pod 的个数上限。</li>
</ul>
<p>我们先输入命令回滚我们的 deployment，输入 <code>kubectl describe pod</code> 会发现 deployment 已经把 <code>v2</code> 版本的 pod 回滚到 <code>v1</code> 的版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#回滚到上版本</span><br>kubectl rollout undo deployment hellok8s-deployment<br><br>kubectl get pods<br>NAME                                   READY   STATUS    RESTARTS   AGE<br>hellok8s-deployment-74fb85d55c-976mz   1/1     Running   0          14s<br>hellok8s-deployment-74fb85d55c-l6p5q   1/1     Running   0          11s<br>hellok8s-deployment-74fb85d55c-qbd4w   1/1     Running   0          9s<br><br><span class="hljs-comment">#查看pod详细信息</span><br>kubectl describe pod hellok8s-deployment-74fb85d55c-976mz<br>Image:          crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v1<br></code></pre></td></tr></table></figure>

<p>除了上面的命令，还可以用 <code>history</code> 来查看历史版本，<code>--to-revision=2</code> 来回滚到指定版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl rollout history deployment hellok8s-deployment<br>kubectl rollout undo deployment/hellok8s-deployment --to-revision=2<br></code></pre></td></tr></table></figure>

<p>接着设置 <code>strategy=rollingUpdate</code> , <code>maxSurge=1</code> , <code>maxUnavailable=1</code> 和 <code>replicas=3</code> 到 deployment.yaml 文件中。这个参数配置意味着最大可能会创建 4 个 hellok8s pod (replicas + maxSurge)，最小会有 2 个 hellok8s pod 存活 (replicas - maxUnavailable)</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">apiVersion:</span> apps<span class="hljs-symbol">/v1</span><br><span class="hljs-params">kind:</span> Deployment<br><span class="hljs-params">metadata:</span><br>  <span class="hljs-params">name:</span> hellok8s-deployment<br><span class="hljs-params">spec:</span><br>  <span class="hljs-params">strategy:</span><br>     <span class="hljs-params">rollingUpdate:</span><br>      <span class="hljs-params">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-params">maxUnavailable:</span> <span class="hljs-number">1</span><br>  <span class="hljs-params">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-params">selector:</span><br>    <span class="hljs-params">matchLabels:</span><br>      <span class="hljs-params">app:</span> hellok8s<br>  <span class="hljs-params">template:</span><br>    <span class="hljs-params">metadata:</span><br>      <span class="hljs-params">labels:</span><br>        <span class="hljs-params">app:</span> hellok8s<br>    <span class="hljs-params">spec:</span><br>      <span class="hljs-params">containers:</span><br>        <span class="hljs-operator">-</span> <span class="hljs-params">name:</span> hellok8s-container<br>          <span class="hljs-params">image:</span> crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com<span class="hljs-operator">/</span>xpshub<span class="hljs-operator">/</span>k8s:v2<br>      <span class="hljs-params">imagePullSecrets:</span><br>        <span class="hljs-operator">-</span> <span class="hljs-params">name:</span> 阿里云密码<br></code></pre></td></tr></table></figure>

<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/rollingupdate.png" srcset="/img/loading.gif" lazyload alt="rollingupdate"></p>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>经过前面几节的练习，可能你会有一些疑惑：</p>
<ul>
<li>为什么 pod 不就绪 (Ready) 的话，<code>kubernetes</code> 不会将流量重定向到该 pod，这是怎么做到的？</li>
<li>前面访问服务的方式是通过 <code>port-forword</code> 将 pod 的端口暴露到本地，不仅需要写对 pod 的名字，一旦 deployment 重新创建新的 pod，pod 名字和 IP 地址也会随之变化，如何保证稳定的访问地址呢？。</li>
<li>如果使用 deployment 部署了多个 Pod 副本，如何做负载均衡呢？</li>
</ul>
<p><code>kubernetes</code> 提供了一种名叫 <code>Service</code> 的资源帮助解决这些问题，它为 pod 提供一个稳定的 Endpoint。Service 位于 pod 的前面，负责接收请求并将它们传递给它后面的所有pod。一旦服务中的 Pod 集合发生更改，Endpoints 就会被更新，请求的重定向自然也会导向最新的 pod。</p>
<h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p>我们先来看看 <code>Service</code> 默认使用的 <code>ClusterIP</code> 类型，首先做一些准备工作，在之前的 <code>hellok8s:v2</code> 版本上加上返回当前服务所在的 <code>hostname</code> 功能，升级到 <code>v3</code> 版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	host, _ := os.Hostname()<br>	io.WriteString(w, fmt.Sprintf(<span class="hljs-string">&quot;[v3] Hello, Kubernetes!, From host: %s&quot;</span>, host))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 和之前保持一致，打包 <code>tag=v3</code> 并推送到远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t hellok8s:v3<br>docker push hellok8s:v3<br></code></pre></td></tr></table></figure>

<p>修改 deployment 的 <code>hellok8s</code> 为 <code>v3</code> 版本。执行 <code>kubectl apply -f deployment.yaml</code> 更新 deployment。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v3</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>

<p>接下来是 <code>Service</code> 资源的定义，我们使用 <code>ClusterIP</code> 的方式定义 Service，通过 <code>kubernetes</code> 集群的内部 IP 暴露服务，当我们只需要让集群中运行的其他应用程序访问我们的 pod 时，就可以使用这种类型的Service。首先创建一个 service-hellok8s-clusterip.yaml 文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8s-clusterip</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">3000</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure>

<p>首先通过 <code>kubectl get endpoints</code> 来看看 Endpoint。被 selector 选中的 Pod，就称为 Service 的 Endpoints。它维护着 Pod 的 IP 地址，只要服务中的 Pod 集合发生更改，Endpoints 就会被更新。通过 <code>kubectl get pod -o wide</code> 命令获取 Pod 更多的信息，可以看到 3 个 Pod 的 IP 地址和 Endpoints 中是保持一致的，你可以试试增大或减少 Deployment 中 Pod 的 replicas，观察 Endpoints 会不会发生变化。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f service-hellok8s-clusterip.yaml<br><br>kubectl get endpoints<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                         ENDPOINTS                                          AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">service-hellok8s-clusterip   172.17.0.10:3000,172.17.0.2:3000,172.17.0.3:3000   10s</span><br><br>kubectl get pod -o wide<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS    RESTARTS   AGE    IP           NODE</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-24lw5   1/1     Running   0          112s   172.17.0.7   minikube</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-9g94t   1/1     Running   0          112s   172.17.0.3   minikube</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-9gm8r   1/1     Running   0          112s   172.17.0.2   minikube</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx                                  1/1     Running   0          112s   172.17.0.9   minikube</span><br><br>kubectl get service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">service-hellok8s-clusterip   ClusterIP   10.104.96.153   &lt;none&gt;        3000/TCP   10s</span><br></code></pre></td></tr></table></figure>

<p>接着我们可以通过在集群其它应用中访问 <code>service-hellok8s-clusterip</code> 的 IP 地址 <code>10.104.96.153</code> 来访问 <code>hellok8s:v3</code> 服务。</p>
<p>但是<code>ClusterIP</code> 的方式只能集群内部访问，不能容器外部访问</p>
<p>这里通过在集群内创建一个 <code>nginx</code> 来访问 <code>hellok8s</code> 服务。创建后进入 <code>nginx</code> 容器来用 <code>curl</code> 命令访问 <code>service-hellok8s-clusterip</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">pods</span><br><span class="hljs-comment"># NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-comment"># hellok8s-deployment-5d5545b69c-24lw5   1/1     Running   0          27m</span><br><span class="hljs-comment"># hellok8s-deployment-5d5545b69c-9g94t   1/1     Running   0          27m</span><br><span class="hljs-comment"># hellok8s-deployment-5d5545b69c-9gm8r   1/1     Running   0          27m</span><br><span class="hljs-comment"># nginx                                  1/1     Running   0          41m</span><br><br><span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">service</span><br><span class="hljs-comment"># NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="hljs-comment"># service-hellok8s-clusterip   ClusterIP   10.104.96.153   &lt;none&gt;        3000/TCP   10s</span><br><br><span class="hljs-string">kubectl</span> <span class="hljs-string">exec</span> <span class="hljs-string">-it</span> <span class="hljs-string">nginx-pod</span> <span class="hljs-string">--</span> <span class="hljs-string">/bin/bash</span><br><span class="hljs-comment"># root@nginx-pod:/# curl 10.104.96.153:3000</span><br><span class="hljs-comment"># [v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9gm8r</span><br><span class="hljs-comment"># root@nginx-pod:/# curl 10.104.96.153:3000</span><br><span class="hljs-comment">#[v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9g94t</span><br></code></pre></td></tr></table></figure>

<p>可以看到，我们多次 <code>curl 10.104.96.153:3000</code> 访问 <code>hellok8s</code> Service IP 地址，返回的 <code>hellok8s:v3</code> <code>hostname</code> 不一样，说明 Service 可以接收请求并将它们传递给它后面的所有 pod，还可以自动负载均衡。你也可以试试增加或者减少 <code>hellok8s:v3</code> pod 副本数量，观察 Service 的请求是否会动态变更。调用过程如下图所示：</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-clusterip-fix-name.png" srcset="/img/loading.gif" lazyload alt="service-clusterip-fix-name"></p>
<p>除了上述的 <code>ClusterIp</code> 的方式外，Kubernetes <code>ServiceTypes</code> 允许指定你所需要的 Service 类型，默认是 <code>ClusterIP</code>。<code>Type</code> 的值包括如下：</p>
<ul>
<li><code>ClusterIP</code>：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 <code>ServiceType</code>。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport"><code>NodePort</code></a>：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a>：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname"><code>ExternalName</code></a>：通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li>
</ul>
<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p>我们知道<code>kubernetes</code> 集群并不是单机运行，它管理着多台节点即 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/">Node</a>，可以通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。如下图所示，如果集群内有两台 Node 运行着 <code>hellok8s:v3</code>，我们创建一个 <code>NodePort</code> 类型的 Service，将 <code>hellok8s:v3</code> 的 <code>3000</code> 端口映射到 Node 机器的 <code>30000</code> 端口 (在 30000-32767 范围内)，就可以通过访问 <code>http://node1-ip:30000</code> 或者 <code>http://node2-ip:30000</code> 访问到服务。</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-nodeport-fix-name.png" srcset="/img/loading.gif" lazyload alt="service-nodeport-fix-name"></p>
<p>这里以 <code>minikube</code> 为例，我们可以通过 <code>minikube ip</code> 命令拿到 k8s cluster node IP地址。下面的教程都以我本机的 <code>192.168.49.2</code> 为例，需要替换成你的 IP 地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">minikube ip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">192.168.49.2</span><br></code></pre></td></tr></table></figure>

<p>接着以 NodePort 的 ServiceType 创建一个 Service 来接管 pod 流量。通过<code>minikube</code> 节点上的 IP <code>192.168.49.2</code> 暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code> – <code>192.168.49.2:30000</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务，最终重定向到 <code>hellok8s:v3</code> 的 <code>3000</code> 端口。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8s-nodeport</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">30000</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure>

<p>创建 <code>service-hellok8s-nodeport</code> Service 后，使用 <code>curl</code> 命令或者浏览器访问 <code>http://192.168.49.2:30000</code> 可以得到结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f service-hellok8s-nodeport.yaml<br><br>kubectl get service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">kubectl get services</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">kubernetes                   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          35h</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">service-hellok8s-clusterip   ClusterIP   10.97.187.137    &lt;none&gt;        4000/TCP         20h</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">service-hellok8s-nodeport    NodePort    10.102.199.168   &lt;none&gt;        3000:30000/TCP   20h</span><br><br>kubectl get pods<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-24lw5   1/1     Running   0          27m</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-9g94t   1/1     Running   0          27m</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5d5545b69c-9gm8r   1/1     Running   0          27m</span><br><br>curl http://192.168.49.2:30000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9g94t</span><br><br>curl http://192.168.49.2:30000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-24lw5</span><br></code></pre></td></tr></table></figure>

<p>如果本地使用 Docker Desktop（minikube start –driver&#x3D;docker）的话，那你大概率无法通过<code>minikube ip</code>获取到的ip地址来请求,因为 docker 部分网络限制导致无法通过 ip 直连 docker container，这代表 NodePort 类型的 Service、Ingress 组件都无法通过 minikube ip 提供的 ip 地址来访问。无法直接访问Node IP。你可以通过<code>minikube service service-hellok8s-nodeport --url</code>来公开服务，然后通过<code>curl</code>或者浏览器访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">minikube service service-hellok8s-nodeport --url<br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:50896</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Because you are using a Docker driver on windows, the terminal needs to be open to run it.</span><br>curl http://127.0.0.1:50896<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-559cfdd58c-zp2pc</span><br>curl http://127.0.0.1:50896<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v3] Hello, Kubernetes!, From host: hellok8s-deployment-559cfdd58c-2j2x2</span><br></code></pre></td></tr></table></figure>

<h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a> 是使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上，假如你在 <a target="_blank" rel="noopener" href="https://aws.amazon.com/">AWS</a> 的 <a target="_blank" rel="noopener" href="https://aws.amazon.com/eks/">EKS</a> 集群上创建一个 Type 为 <code>LoadBalancer</code> 的 Service。它会自动创建一个 ELB (<a target="_blank" rel="noopener" href="https://aws.amazon.com/elasticloadbalancing">Elastic Load Balancer</a>) ，并可以根据配置的 IP 池中自动分配一个独立的 IP 地址，可以供外部访问。</p>
<p>这里因为我们使用的是 <code>minikube</code>，可以使用 <code>minikube tunnel</code> 来辅助创建 LoadBalancer 的 <code>EXTERNAL_IP</code>，具体教程可以查看<a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access">官网文档</a>，但是和实际云提供商的 LoadBalancer 还是有本质区别，所以 <a target="_blank" rel="noopener" href="https://github.com/guangzhengli/kubernetes_workshop">Repository</a> 不做更多阐述，有条件的可以使用 <a target="_blank" rel="noopener" href="https://aws.amazon.com/">AWS</a> 的 <a target="_blank" rel="noopener" href="https://aws.amazon.com/eks/">EKS</a> 集群上创建一个 ELB (<a target="_blank" rel="noopener" href="https://aws.amazon.com/elasticloadbalancing">Elastic Load Balancer</a>) 试试。</p>
<p>下图显示 LoadBalancer 的 Service 架构图。</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/service-loadbalancer-fix-name.png" srcset="/img/loading.gif" lazyload alt="service-loadbalancer-fix-name"></p>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#ingress-v1beta1-networking-k8s-io">Ingress</a> 公开从集群外部到集群内<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">服务</a>的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、 SSL&#x2F;TLS，以及基于名称的虚拟托管。你必须拥有一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers">Ingress 控制器</a> 才能满足 Ingress 的要求。 仅创建 Ingress 资源本身没有任何效果。 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers">Ingress 控制器</a> 通常负责通过负载均衡器来实现 Ingress，例如 <code>minikube</code> 默认使用的是 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/">nginx-ingress</a>，目前 <code>minikube</code> 也支持 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/handbook/addons/kong-ingress/">Kong-Ingress</a>。</p>
<p>Ingress 可以“简单理解”为服务的网关 Gateway，它是所有流量的入口，经过配置的路由规则，将流量重定向到后端的服务。</p>
<p>在 <code>minikube</code> 中，可以通过下面命令开启 Ingress-Controller 的功能。默认使用的是 <a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/">nginx-ingress</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">minikube addons enable ingress<br></code></pre></td></tr></table></figure>

<p>接着删除之前创建的所有 <code>pod</code>, <code>deployment</code>, <code>service</code> 资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete deployment,service --all<br></code></pre></td></tr></table></figure>

<p>接着根据之前的教程，创建 <code>hellok8s:v2</code> 和 <code>hellok8s:v1</code> 的<code>deployment</code>与 <code>service</code> 资源。Service 的 type 为 ClusterIP 即可。</p>
<p><code>hellok8s:v2</code> 的端口映射为 <code>4000:3000</code>，<code>hellok8s:v1</code> 的端口映射为 <code>5000:3000</code>，这里后续写 Ingress Route 规则时会用到。</p>
<p><code>hellok8s</code>配置:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8sv2-clusterip</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv2</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">4000</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3000</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8sv2-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv2</span><br>     <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8sv2-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v2</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>

<p><code>nginx</code>配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8sv1-clusterip</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv1</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3000</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8sv1-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8sv1</span><br>     <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8sv1-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">crpi-g07m1i4cb9anpvun.cn-hangzhou.personal.cr.aliyuncs.com/xpshub/k8s:v1</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">阿里云密码</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f hellok8sv1.yaml                 <br><span class="hljs-comment"># service/service-hellok8sv1-clusterip created</span><br><span class="hljs-comment"># deployment.apps/hellok8sv1-deployment created</span><br><br>kubectl apply -f hellok8sv2.yaml   <br><span class="hljs-comment"># service/service-hellok8sv2-clusterip created</span><br><span class="hljs-comment"># deployment.apps/hellok8sv2-deployment created</span><br><br>kubectl get pods            <br><span class="hljs-comment">#NAME                                     READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-comment">#hellok8sv1-deployment-7454486bb7-f6wjx   1/1     Running   0          7m26s</span><br><span class="hljs-comment">#hellok8sv1-deployment-7454486bb7-wpns2   1/1     Running   0          7m26s</span><br><span class="hljs-comment">#hellok8sv2-deployment-586f4fccfd-5szpg   1/1     Running   0          8m50s</span><br><span class="hljs-comment">#hellok8sv2-deployment-586f4fccfd-72dbg   1/1     Running   0          8m50s</span><br><span class="hljs-comment">#hellok8sv2-deployment-586f4fccfd-vmkvl   1/1     Running   0          8m50s</span><br><br><br>kubectl get service<br><span class="hljs-comment">#NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="hljs-comment">#kubernetes                     ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    22m</span><br><span class="hljs-comment">#service-hellok8sv1-clusterip   ClusterIP   10.108.219.83   &lt;none&gt;        3000/TCP   6m2s</span><br><span class="hljs-comment">#service-hellok8sv2-clusterip   ClusterIP   10.101.123.50   &lt;none&gt;        3000/TCP   6m26s</span><br><br></code></pre></td></tr></table></figure>

<p>这样在 k8s 集群中，就有 3 个 <code>hellok8s:v2</code> 的 pod，2 个 <code>hellok8s:v1</code> 的 pod。并且<code>hellok8s:v2</code> 的端口映射为 <code>4000:3000</code>，<code>hellok8s:v1</code> 的端口映射为 <code>5000:3000</code>。在这个基础上，接下来编写 Ingress 资源的定义，<code>nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;</code> 的意思是这里关闭 <code>https</code> 连接，只使用 <code>http</code> 连接。</p>
<p>匹配前缀为 <code>/hello</code> 的路由规则，重定向到 <code>hellok8s:v3</code> 服务，匹配前缀为 <code>/</code> 的跟路径重定向到 <code>nginx</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># We are defining this annotation to prevent nginx</span><br>    <span class="hljs-comment"># from redirecting requests to `https` for now</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="hljs-string">&quot;false&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>      <span class="hljs-attr">http:</span><br>        <span class="hljs-attr">paths:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span><br>            <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8sv2-clusterip</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">4000</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>            <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">service-hellok8sv1-clusterip</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f ingress.yaml<br><span class="hljs-comment"># ingress.extensions/hello-ingress created</span><br><br>kubectl get ingress          <br><span class="hljs-comment"># NAME            CLASS   HOSTS   ADDRESS   PORTS   AGE</span><br><span class="hljs-comment"># hello-ingress   nginx   *                 80      16s</span><br><br><span class="hljs-comment"># replace 192.168.49.2 by your minikube ip</span><br>curl -H <span class="hljs-string">&quot;Host: localhost&quot;</span> http://192.168.49.2/hello<br><span class="hljs-comment"># [v2] Hello, Kubernetes!</span><br><br>curl -H <span class="hljs-string">&quot;Host: localhost&quot;</span> http://192.168.49.2/<br><span class="hljs-comment"># [v1] Hello, Kubernetes!</span><br></code></pre></td></tr></table></figure>

<p>这里和service一样，如果本地使用 Docker Desktop（minikube start –driver&#x3D;docker）的话，那你大概率无法通过minikube ip获取到的ip地址来请求，你可以先通过<code>minikube service list</code>来查看服务列表，然后通过<code>minikube service ingress-nginx-controller -n ingress-nginx --url</code>来公开服务，然后通过<code>curl</code>或者浏览器来访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">minikube service list<br><span class="hljs-meta prompt_">#</span><span class="language-bash">|---------------|------------------------------------|--------------|---------------------------|</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">|   NAMESPACE   |                NAME                | TARGET PORT  |            URL            |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">|---------------|------------------------------------|--------------|---------------------------|</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| default       | kubernetes                         | No node port |                           |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| default       | service-hellok8sv1-clusterip       | No node port |                           |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| default       | service-hellok8sv2-clusterip       | No node port |                           |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| ingress-nginx | ingress-nginx-controller           | http/80      | http://192.168.49.2:30288 |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">|               |                                    | https/443    | http://192.168.49.2:31616 |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| ingress-nginx | ingress-nginx-controller-admission | No node port |                           |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">| kube-system   | kube-dns                           | No node port |                           |</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">|---------------|------------------------------------|--------------|---------------------------|</span><br>minikube service ingress-nginx-controller -n ingress-nginx --url<br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:61691      http</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:61692      https</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">❗  Because you are using a Docker driver on windows, the terminal needs to be open to run it.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第一个是http，第二个是https，这里我们只需要http，所以我们只需要第一个地址</span><br></code></pre></td></tr></table></figure>

<p>上面的教程中将所有流量都发送到 Ingress 中，如下图所示：</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/ingress.png" srcset="/img/loading.gif" lazyload alt="ingress"></p>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>在实际的开发当中，有时候我们需要不同的环境来做开发和测试，例如 <code>dev</code> 环境给开发使用，<code>test</code> 环境给 QA 使用，那么 k8s 能不能在不同环境 <code>dev</code> <code>test</code> <code>uat</code> <code>prod</code> 中区分资源，让不同环境的资源独立互相不影响呢，答案是肯定的，k8s 提供了名为 Namespace 的资源来帮助隔离资源。</p>
<p>在 Kubernetes 中，<strong>名字空间（Namespace）</strong> 提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求。 名字空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等。</p>
<p>前面的教程中，默认使用的 namespace 是 <code>default</code>。</p>
<p>下面展示如何创建一个新的 namespace， <code>namespace.yaml</code> 文件定义了两个不同的 namespace，分别是 <code>dev</code> 和 <code>test</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br>  <br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure>

<p>可以通过<code>kubectl apply -f namespaces.yaml</code> 创建两个新的 namespace，分别是 <code>dev</code> 和 <code>test</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">namespaces.yaml</span>    <br><span class="hljs-comment"># namespace/dev created</span><br><span class="hljs-comment"># namespace/test created</span><br><br><br><span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">namespaces</span>          <br><span class="hljs-comment"># NAME              STATUS   AGE</span><br><span class="hljs-comment"># default           Active   215d</span><br><span class="hljs-comment"># dev               Active   2m44s</span><br><span class="hljs-comment"># ingress-nginx     Active   110d</span><br><span class="hljs-comment"># kube-node-lease   Active   215d</span><br><span class="hljs-comment"># kube-public       Active   215d</span><br><span class="hljs-comment"># kube-system       Active   215d</span><br><span class="hljs-comment"># test              Active   2m44s</span><br></code></pre></td></tr></table></figure>

<p>那么如何在新的 namespace 下创建资源和获取资源呢？只需要在命令后面加上 <code>-n namespace</code> 即可。例如根据上面教程中，在名为 <code>dev</code> 的 namespace 下创建 <code>hellok8s:v3</code> 的 deployment 资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f deployment.yaml -n dev<br><br>kubectl get pods -n dev<br></code></pre></td></tr></table></figure>



<h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>上面的教程提到，我们在不同环境 <code>dev</code> <code>test</code> <code>uat</code> <code>prod</code> 中区分资源，可以让其资源独立互相不受影响，但是随之而来也会带来一些问题，例如不同环境的数据库的地址往往是不一样的，那么如果在代码中写同一个数据库的地址，就会出现问题。</p>
<p>K8S 使用 ConfigMap 来将你的配置数据和应用程序代码分开，将非机密性的数据保存到键值对中。ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。如果你需要保存超出此尺寸限制的数据，你可能考虑挂载存储卷。</p>
<p>下面我们可以来看一个例子，我们修改之前代码，假设不同环境的数据库地址不同，下面代码从环境变量中获取 <code>DB_URL</code>，并将它返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	host, _ := os.Hostname()<br>	dbURL := os.Getenv(<span class="hljs-string">&quot;DB_URL&quot;</span>)<br>	io.WriteString(w, fmt.Sprintf(<span class="hljs-string">&quot;[v4] Hello, Kubernetes! From host: %s, Get Database Connect URL: %s&quot;</span>, host, dbURL))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构建 <code>hellok8s:v4</code> 的镜像，推送到远程仓库。并删除之前创建的所有资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t guangzhengli/hellok8s:v4<br>docker push guangzhengli/hellok8s:v4<br><br>kubectl delete deployment,service,ingress --all<br></code></pre></td></tr></table></figure>

<p>接下来创建不同 namespace 的 configmap 来存放 <code>DB_URL</code>。</p>
<p>创建 <code>hellok8s-config-dev.yaml</code> 文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-config</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">DB_URL:</span> <span class="hljs-string">&quot;http://DB_ADDRESS_DEV&quot;</span><br></code></pre></td></tr></table></figure>

<p>创建 <code>hellok8s-config-test.yaml</code> 文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-config</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">DB_URL:</span> <span class="hljs-string">&quot;http://DB_ADDRESS_TEST&quot;</span><br></code></pre></td></tr></table></figure>

<p>分别在 <code>dev</code> <code>test</code> 两个 namespace 下创建相同的 <code>ConfigMap</code>，名字都叫 hellok8s-config，但是存放的 Pair 对中 Value 值不一样。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f hellok8s-config-dev.yaml -n dev<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configmap/hellok8s-config created</span><br><br>kubectl apply -f hellok8s-config-test.yaml -n test <br><span class="hljs-meta prompt_"># </span><span class="language-bash">configmap/hellok8s-config created</span><br><br>kubectl get configmap --all-namespaces<br>NAMESPACE         NAME                                 DATA   AGE<br>dev               hellok8s-config                      1      3m12s<br>test              hellok8s-config                      1      2m1s<br></code></pre></td></tr></table></figure>

<p>接着使用 POD 的方式来部署 <code>hellok8s:v4</code>，其中 <code>env.name</code> 表示的是将 configmap 中的值写进环境变量，这样代码从环境变量中获取 <code>DB_URL</code>，这个 KEY 名称必须保持一致。<code>valueFrom</code> 代表从哪里读取，<code>configMapKeyRef</code> 这里表示从名为 <code>hellok8s-config</code> 的 <code>configMap</code> 中读取 <code>KEY=DB_URL</code> 的 Value。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">guangzhengli/hellok8s:v4</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DB_URL</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">configMapKeyRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-config</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">DB_URL</span><br></code></pre></td></tr></table></figure>

<p>下面分别在 <code>dev</code> <code>test</code> 两个 namespace 下创建 <code>hellok8s:v4</code>，接着通过 <code>port-forward</code> 的方式访问不同 namespace 的服务，可以看到返回的 <code>Get Database Connect URL: http://DB_ADDRESS_TEST</code> 是不一样的！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f hellok8s.yaml -n dev             <br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod/hellok8s-pod created</span><br><br>kubectl apply -f hellok8s.yaml -n test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod/hellok8s-pod created</span><br><br>kubectl port-forward hellok8s-pod 3000:3000 -n dev<br><br>curl http://localhost:3000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v4] Hello, Kubernetes! From host: hellok8s-pod, Get Database Connect URL: http://DB_ADDRESS_DEV</span><br><br>kubectl port-forward hellok8s-pod 3000:3000 -n test<br><br>curl http://localhost:3000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v4] Hello, Kubernetes! From host: hellok8s-pod, Get Database Connect URL: http://DB_ADDRESS_TEST</span><br></code></pre></td></tr></table></figure>

<h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>上面提到，我们会选择以 configmap 的方式挂载配置信息，但是当我们的配置信息需要加密的时候， configmap 就无法满足这个要求。例如上面要挂载数据库密码的时候，就需要明文挂载。</p>
<p>这个时候就需要 Secret 来存储加密信息，虽然在资源文件的编码上，只是通过 Base64 的方式简单编码，但是在实际生产过程中，可以通过 pipeline 或者专业的 <a target="_blank" rel="noopener" href="https://aws.amazon.com/kms/">AWS KMS</a> 服务进行密钥管理。这样就大大减少了安全事故。</p>
<blockquote>
<p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。由于创建 Secret 可以独立于使用它们的 Pod， 因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。 Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施， 例如避免将机密数据写入非易失性存储。</p>
<p>默认情况下，Kubernetes Secret 未加密地存储在 API 服务器的底层数据存储（etcd）中。 任何拥有 API 访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。 此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret； 这包括间接访问，例如创建 Deployment 的能力。</p>
<p>为了安全地使用 Secret，请至少执行以下步骤：</p>
<ol>
<li>为 Secret <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">启用静态加密</a>；</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">启用或配置 RBAC 规则</a>来限制读取和写入 Secret 的数据（包括通过间接方式）。需要注意的是，被准许创建 Pod 的人也隐式地被授权获取 Secret 内容。</li>
<li>在适当的情况下，还可以使用 RBAC 等机制来限制允许哪些主体创建新 Secret 或替换现有 Secret。</li>
</ol>
</blockquote>
<p>Secret 的资源定义和 ConfigMap 结构基本一致，唯一区别在于 kind 是 <code>Secret</code>，还有 Value 需要 Base64 编码，你可以通过下面命令快速 Base64 编解码。当然 Secret 也提供了一种 <code>stringData</code>，可以不需要 Base64 编码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;db_password&quot; | base64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ZGJfcGFzc3dvcmQK</span><br><br>echo &quot;ZGJfcGFzc3dvcmQK&quot; | base64 -d<br><span class="hljs-meta prompt_"># </span><span class="language-bash">db_password</span><br></code></pre></td></tr></table></figure>

<p>这里将 Base64 编码过后的值，填入对应的 key - value 中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># hellok8s-secret.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-secret</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">DB_PASSWORD:</span> <span class="hljs-string">&quot;ZGJfcGFzc3dvcmQK&quot;</span><br><span class="hljs-comment"># hellok8s.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">guangzhengli/hellok8s:v5</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DB_PASSWORD</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">secretKeyRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-secret</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">DB_PASSWORD</span><br><span class="hljs-string">package</span> <span class="hljs-string">main</span><br><br><span class="hljs-string">import</span> <span class="hljs-string">(</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">)</span><br><br><span class="hljs-string">func</span> <span class="hljs-string">hello(w</span> <span class="hljs-string">http.ResponseWriter,</span> <span class="hljs-string">r</span> <span class="hljs-string">*http.Request)</span> &#123;<br>	<span class="hljs-string">host</span>, <span class="hljs-string">_</span> <span class="hljs-string">:=</span> <span class="hljs-string">os.Hostname()</span><br>	<span class="hljs-string">dbPassword</span> <span class="hljs-string">:=</span> <span class="hljs-string">os.Getenv(&quot;DB_PASSWORD&quot;)</span><br>	<span class="hljs-string">io.WriteString(w</span>, <span class="hljs-string">fmt.Sprintf(&quot;</span>[<span class="hljs-string">v5</span>] <span class="hljs-string">Hello</span>, <span class="hljs-string">Kubernetes!</span> <span class="hljs-attr">From host:</span> <span class="hljs-string">%s</span>, <span class="hljs-attr">Get Database Connect Password:</span> <span class="hljs-string">%s&quot;</span>, <span class="hljs-string">host</span>, <span class="hljs-string">dbPassword))</span><br>&#125;<br><br><span class="hljs-string">func</span> <span class="hljs-string">main()</span> &#123;<br>	<span class="hljs-string">http.HandleFunc(&quot;/&quot;</span>, <span class="hljs-string">hello)</span><br>	<span class="hljs-string">http.ListenAndServe(&quot;:3000&quot;</span>, <span class="hljs-string">nil)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在代码中读取 <code>DB_PASSWORD</code> 环境变量，直接返回对应字符串。Secret 的使用方法和前面教程中 ConfigMap 基本一致，这里就不再过多赘述。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t guangzhengli/hellok8s:v5<br><br>docker push guangzhengli/hellok8s:v5<br><br>kubectl apply -f hellok8s-secret.yaml<br><br>kubectl apply -f hellok8s.yaml<br><br>kubectl port-forward hellok8s-pod 3000:3000<br></code></pre></td></tr></table></figure>

<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p>在实际的开发过程中，还有一类任务是之前的资源不能满足的，即一次性任务。例如常见的计算任务，只需要拿到相关数据计算后得出结果即可，无需一直运行。而处理这一类任务的资源就是 Job。</p>
<blockquote>
<p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>
<p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p>
</blockquote>
<p>下面来看一个 Job 的资源定义，其中 Kind 和 metadata.name 是资源类型和名字就不再解释，<code>completions</code> 指的是会创建 Pod 的数量，每个 pod 都会完成下面的任务。<code>parallelism</code> 指的是并发执行最大数量，例如下面就会先创建 3 个 pod 并发执行任务，一旦某个 pod 执行完成，就会再创建新的 pod 来执行，直到 5 个 pod 执行完成，Job 才会被标记为完成。</p>
<p><code>restartPolicy = &quot;OnFailure</code> 的含义和 Pod 生命周期相关，Pod 中的容器可能因为退出时返回值非零， 或者容器因为超出内存约束而被杀死等等。 如果发生这类事件，并且 <code>.spec.template.spec.restartPolicy = &quot;OnFailure&quot;</code>， Pod 则继续留在当前节点，但容器会被重新运行。因此，你的程序需要能够处理在本地被重启的情况，或者要设置 <code>.spec.template.spec.restartPolicy = &quot;Never&quot;</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">echo</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>          <span class="hljs-attr">command:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done&quot;</span><br></code></pre></td></tr></table></figure>

<p>通过下面的命令创建 job，可以通过 <code>kubectl get pods -w</code> 来观察 job 创建 pod 的过程和结果。最后可以通过 <code>logs</code> 命令查看日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f hello-job.yaml<br><br>kubectl get jobs                  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME        COMPLETIONS   DURATION   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job   5/5           19s        83s</span><br><br>kubectl get pods                      <br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS      RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job--1-5gjjr                     0/1     Completed   0          34s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job--1-8ffmn                     0/1     Completed   0          26s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job--1-ltsvm                     0/1     Completed   0          34s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job--1-mttwv                     0/1     Completed   0          29s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-job--1-ww2qp                     0/1     Completed   0          34s</span><br><br>kubectl logs -f hello-job--1-5gjjr <br><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></td></tr></table></figure>

<p>Job 完成时不会再创建新的 Pod，不过已有的 Pod <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy">通常</a>也不会被删除。 保留这些 Pod 使得你可以查看已完成的 Pod 的日志输出，以便检查错误、警告或者其它诊断性输出。 可以使用 <code>kubectl</code> 来删除 Job（例如 <code>kubectl delete -f hello-job.yaml</code>)。当使用 <code>kubectl</code> 来删除 Job 时，该 Job 所创建的 Pod 也会被删除。</p>
<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p><em>CronJob</em> 可以理解为定时任务，创建基于 Cron 时间调度的 <a target="_blank" rel="noopener" href="https://kubernetes.ion/docs/concepts/workloads/controllers/job/">Jobs</a>。</p>
<blockquote>
<p>CronJob 用于执行周期性的动作，例如备份、报告生成等。 这些任务中的每一个都应该配置为周期性重复的（例如：每天&#x2F;每周&#x2F;每月一次）； 你可以定义任务开始执行的时间间隔。</p>
</blockquote>
<p>Cron 时间表语法</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section"># ┌───────────── 分钟 (0 - 59)</span><br><span class="hljs-section"># │ ┌───────────── 小时 (0 - 23)</span><br><span class="hljs-section"># │ │ ┌───────────── 月的某天 (1 - 31)</span><br><span class="hljs-section"># │ │ │ ┌───────────── 月份 (1 - 12)</span><br><span class="hljs-section"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周一；在某些系统上，7 也是星期日）</span><br><span class="hljs-section"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span><br><span class="hljs-section"># │ │ │ │ │</span><br><span class="hljs-section"># │ │ │ │ │</span><br><span class="hljs-section"># * * * * <span class="hljs-emphasis">*</span></span><br></code></pre></td></tr></table></figure>

<p>用法除了需要加上 cron 表达式之外，其余基本和 Job 保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-cronjob</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">&quot;* * * * *&quot;</span> <span class="hljs-comment"># Every minute</span><br>  <span class="hljs-attr">jobTemplate:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br>          <span class="hljs-attr">containers:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">echo</span><br>              <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>              <span class="hljs-attr">command:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br>              <span class="hljs-attr">args:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done&quot;</span><br></code></pre></td></tr></table></figure>

<p>使用命令和 Job 也基本保持一致，这里就不过多赘述。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f hello-cronjob.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">cronjob.batch/hello-cronjob created</span><br><br>kubectl get cronjob                <br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME            SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-cronjob   * * * * *   False     0        &lt;none&gt;          8s</span><br><br>kubectl get pods   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS      RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-cronjob-27694609--1-2nmdx        0/1     Completed   0          15s</span><br></code></pre></td></tr></table></figure>

<h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><p>2025年4月11日 · 2311 字</p>
<p>经过前面的教程，想必你已经对 kubernetes 的使用有了一定的理解。但是不知道你是否想过这样一个问题，就是我们前面教程中提到的所有资源，包括用 <code>pod</code>, <code>deployment</code>, <code>service</code>, <code>ingress</code>, <code>configmap</code>,<code>secret</code> 所有资源来部署一套完整的 <code>hellok8s</code> 服务的话，难道需要一个一个的 <code>kubectl apply -f</code> 来创建吗？如果换一个 namespace，或者说换一套 kubernetes 集群部署的话，又要重复性的操作创建的过程吗？</p>
<p>我们平常使用操作系统时，需要安装一个应用的话，可以直接使用 <code>apt</code> 或者 <code>brew</code> 来直接安装，而不需要关心这个应用需要哪些依赖，哪些配置。在使用 kubernetes 安装应用服务 <code>hellok8s</code> 时，我们自然也希望能够一个命令就安装完成，而提供这个能力的，就是 CNCF 的毕业项目 <a target="_blank" rel="noopener" href="https://github.com/helm/helm">Helm</a>。</p>
<blockquote>
<p>Helm 帮助您管理 Kubernetes 应用—— Helm Chart，Helm 是查找、分享和使用软件构建 <a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> 的最优方式。</p>
<p>复杂性管理 ——即使是最复杂的应用，Helm Chart 依然可以描述， 提供使用单点授权的可重复安装应用程序。</p>
<p>易于升级 ——随时随地升级和自定义的钩子消除您升级的痛苦。</p>
<p>分发简单 —— Helm Chart 很容易在公共或私有化服务器上发版，分发和部署站点。</p>
<p>回滚 —— 使用 <code>helm rollback</code> 可以轻松回滚到之前的发布版本。</p>
</blockquote>
<p>我们通过 brew 来安装 helm。更多方式可以参考<a target="_blank" rel="noopener" href="https://helm.sh/zh/docs/intro/install/">官方文档</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install helm<br></code></pre></td></tr></table></figure>

<p>Helm 的使用方式可以解释为：Helm 安装 <em>charts</em> 到 Kubernetes 集群中，每次安装都会创建一个新的 <em>release</em>。你可以在 Helm 的 chart <em>repositories</em> 中寻找新的 chart。</p>
<h2 id="用-helm-安装-hellok8s"><a href="#用-helm-安装-hellok8s" class="headerlink" title="用 helm 安装 hellok8s"></a>用 helm 安装 hellok8s</h2><p>开始本节教程前，我们先把之前手动创建的 hellok8s 相关的资源删除(防止使用 helm 创建同名的 k8s 资源失败)。</p>
<p>在尝试自己创建 hellok8s helm chart 之前，我们可以先来熟悉一下怎么使用 helm chart。在这里我先创建好了一个 hellok8s（包括会创建 deployment, service, ingress, configmaps, secret）的 helm chart。通过 GitHub actions 生成放在了 <a target="_blank" rel="noopener" href="https://github.com/guangzhengli/k8s-tutorials/tree/gh-pages/">gh-pages</a> 分支下的 <code>index.yaml</code> 文件中。</p>
<p>接着可以使用下面命令进行快速安装，其中 <code>helm repo add</code> 表示将我创建好的 hellok8s chart 添加到自己本地的仓库当中，<code>helm install</code> 表示从仓库中安装 hellok8s&#x2F;hello-helm 到 k8s 集群当中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm repo add hellok8s https://guangzhengli.github.io/k8s-tutorials/<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;hellok8s&quot;</span> has been added to your repositories</span><br><br>helm install my-hello-helm hellok8s/hello-helm --version 0.1.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME: my-hello-helm</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAMESPACE: default</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">STATUS: deployed</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">REVISION: 1</span><br></code></pre></td></tr></table></figure>

<p>创建完成后，通过 <code>kubectl get</code> 等命令可以看到所有 hellok8s 资源都创建成功，<code>helm</code> 一条命令即可做到之前教程中所有资源的创建！通过 <code>curl</code> k8s 集群的 ingress 地址，也可以看到返回字符串！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f88f984c6-k8hpz   1/1     Running   0          15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f88f984c6-nzwg6   1/1     Running   0          15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f88f984c6-s89s7   1/1     Running   0          15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx-deployment-d47fd7f66-6w76b      1/1     Running   0          15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx-deployment-d47fd7f66-tsqj5      1/1     Running   0          15h</span><br><br>kubectl get deployments<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                  READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment   3/3     3            3           15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx-deployment      2/2     2            2           15h</span><br><br>kubectl get service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubernetes                   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP    13d</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">service-hellok8s-clusterip   ClusterIP   10.107.198.175   &lt;none&gt;        3000/TCP   15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">service-nginx-clusterip      ClusterIP   10.100.144.49    &lt;none&gt;        4000/TCP   15h</span><br><br>kubectl get ingress<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME               CLASS   HOSTS   ADDRESS     PORTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-ingress   nginx   *       localhost   80      15h</span><br><br>kubectl get configmap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME               DATA   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-config    1      15h</span><br><br>kubectl get secret<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                  TYPE                                  DATA   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-secret                       Opaque                                1      15h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sh.helm.release.v1.my-hello-helm.v1   helm.sh/release.v1</span><br><br>curl http://192.168.59.100/hello<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v6] Hello, Helm! Message from helm values: It works with Helm Values[v2]!, From namespace: default, From host: hellok8s-deployment-598bbd6884-ttk78, Get Database Connect URL: http://DB_ADDRESS_DEFAULT, Database Connect Password: db_password</span><br></code></pre></td></tr></table></figure>

<h2 id="创建-helm-charts"><a href="#创建-helm-charts" class="headerlink" title="创建 helm charts"></a>创建 helm charts</h2><p>这段代码无法渲染，请查看：<a target="_blank" rel="noopener" href="https://github.com/guangzhengli/k8s-tutorials#helm">https://github.com/guangzhengli/k8s-tutorials#helm</a></p>
<h2 id="rollback"><a href="#rollback" class="headerlink" title="rollback"></a>rollback</h2><p>Helm 也提供了 Rollback 的功能，我们先修改一下 <code>message: &quot;It works with Helm Values[v2]!&quot;</code> 加上 [v2]。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">application:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">hellok8s:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">guangzhengli/hellok8s:v6</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;It works with Helm Values[v2]!&quot;</span><br>    <span class="hljs-attr">database:</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://DB_ADDRESS_DEFAULT&quot;</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;db_password&quot;</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>再执行 <code>helm upgrade</code> 命令更新 k8s 资源，通过 <code>curl http://192.168.59.100/hello</code> 可以看到资源已经更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  hello-helm git:(main) ✗ helm upgrade --install hello-helm --values values.yaml .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Release <span class="hljs-string">&quot;hello-helm&quot;</span> has been upgraded. Happy Helming!</span><br>NAME: hello-helm<br>NAMESPACE: default<br>STATUS: deployed<br>REVISION: 2<br><br>curl http://192.168.59.100/hello<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v6] Hello, Helm! Message from helm values: It works with Helm Values[v2]!, From namespace: default, From host: hellok8s-deployment-598bbd6884-4b9bw, Get Database Connect URL: http://DB_ADDRESS_DEFAULT, Database Connect Password: db_password</span><br></code></pre></td></tr></table></figure>

<p>如果这一次更新有问题的话，可以通过 <code>helm rollback</code> 快速回滚。通过下面命令看到，和 deployment 的 rollback 一样，回滚后 REVISION 版本都会增大到 3 而不是回滚到 1，回滚后使用 <code>curl</code> 命令返回的 v1 版本的字符串。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME            NAMESPACE       REVISION          STATUS          CHART                   APP VERSION</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-helm      default         2                 deployed        hello-helm-0.1.0        1.16.0</span> <br><br>helm rollback hello-helm 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Rollback was a success! Happy Helming!</span><br><br>helm ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME            NAMESPACE       REVISION          STATUS          CHART                   APP VERSION</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello-helm      default         3                 deployed        hello-helm-0.1.0        1.16.0</span> <br><br>curl http://192.168.59.100/hello<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v6] Hello, Helm! Message from helm values: It works with Helm Values!, From namespace: default, From host: hellok8s-deployment-57d7df7964-482xw, Get Database Connect URL: http://DB_ADDRESS_DEFAULT, Database Connect Password: db_password</span><br></code></pre></td></tr></table></figure>

<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>使用 Helm 也很容易多环境部署，新建 <code>values-dev.yaml</code> 文件，里面内容自定义 <code>dev</code> 环境需要的配置信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">application:</span><br>  <span class="hljs-attr">hellok8s:</span><br>    <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;It works with Helm Values values-dev.yaml!&quot;</span><br>    <span class="hljs-attr">database:</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://DB_ADDRESS_DEV&quot;</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;db_password_dev&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以多次指定’–values -f’参数，最后（最右边）指定的文件优先级最高，这里最右边的是 <code>values-dev.yaml</code> 文件，所以 <code>values-dev.yaml</code> 文件中的值会覆盖 <code>values.yaml</code> 中相同的值，<code>-n dev</code> 表示在名字为 dev 的 namespace 中创建 k8s 资源，执行完成后，我们可以通过 <code>curl</code> 命令看到返回的字符串中读取的是 <code>values-dev.yaml</code> 文件的配置，并且 <code>From namespace = dev</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm upgrade --install hello-helm -f values.yaml -f values-dev.yaml -n dev .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Release <span class="hljs-string">&quot;hello-helm&quot;</span> does not exist. Installing it now.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME: hello-helm</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAMESPACE: dev</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">STATUS: deployed</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">REVISION: 1</span><br><br>curl http://192.168.59.100/hello<br><span class="hljs-meta prompt_"># </span><span class="language-bash">[v6] Hello, Helm! Message from helm values: It works with Helm Values values-dev.yaml!, From namespace: dev, From host: hellok8s-deployment-f5fff9df-89sn6, Get Database Connect URL: http://DB_ADDRESS_DEV, Database Connect Password: db_password_dev</span><br><br>kubectl get pods -n dev<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f5fff9df-89sn6   1/1     Running   0          4m23s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f5fff9df-tkh6g   1/1     Running   0          4m23s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-f5fff9df-wmlpb   1/1     Running   0          4m23s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx-deployment-d47fd7f66-cdlmf     1/1     Running   0          4m23s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx-deployment-d47fd7f66-cgst2     1/1     Running   0          4m23s</span><br></code></pre></td></tr></table></figure>

<p>除此之外，还可以使用 ‘–set-file’ 设置独立的值，类似于 <code>helm upgrade --install hello-helm -f values.yaml -f values-dev.yaml --set application.hellok8s.message=&quot;It works with set helm values&quot; -n dev .</code> 方式在命令中设置 values 的值，可以随意修改相关配置，此方法在 CICD 中经常用到。</p>
<h2 id="helm-chart-打包和发布"><a href="#helm-chart-打包和发布" class="headerlink" title="helm chart 打包和发布"></a>helm chart 打包和发布</h2><p>上面的例子展示了我们可以用一行命令在一个新的环境中安装所有需要的 k8s 资源！那么如何将 helm chart 打包、分发和下载呢？在官网中，提供了两种教程，一种是以 <a target="_blank" rel="noopener" href="https://helm.sh/zh/docs/howto/chart_repository_sync_example/">GCS 存储的教程</a>，还有一种是以 <a target="_blank" rel="noopener" href="https://helm.sh/zh/docs/howto/chart_releaser_action/">GitHub Pages 存储的教程</a>。</p>
<p>这里我们使用第二种，并且使用 <a target="_blank" rel="noopener" href="https://github.com/helm/chart-releaser-action">chart-releaser-action</a> 来做自动发布，该 action 会默认生成 helm chart 发布到 <code>gh-pages</code> 分支上，本教程的 hellok8s helm chart 就发布在了本仓库的<a target="_blank" rel="noopener" href="https://github.com/guangzhengli/k8s-tutorials/tree/gh-pages/">gh-pages</a> 分支上的 <code>index.yaml</code> 文件中。</p>
<p>在使用 action 自动生成 chart 之前，我们可以先熟悉一下如何手动生成，在 <code>hello-helm</code> 目录下，执行 <code>helm package</code> 将chart目录打包到chart归档中。<code>helm repo index</code> 命令可以基于包含打包chart的目录，生成仓库的索引文件 <code>index.yaml</code>。</p>
<p>最后，可以使用 <code>helm upgrade --install *.tgz</code> 命令将该指定包进行安装使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm package hello-helm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Successfully packaged chart and saved it to: /Users/guangzheng.li/workspace/k8s-tutorials/hello-helm/hello-helm-0.1.0.tgz</span><br><br>helm repo index .<br><br>helm upgrade --install hello-helm hello-helm-0.1.0.tgz<br></code></pre></td></tr></table></figure>

<p>基于上面的步骤，你可能已经想到，所谓的 helm 打包和发布，就是 <code>hello-helm-0.1.0.tgz</code> 文件和 <code>index.yaml</code> 生成和上传的一个过程。而 helm 下载和安装，就是如何将 <code>.tgz</code> 和 <code>index.yaml</code> 文件下载和 <code>helm upgrade --install</code> 的过程。</p>
<p>接下来我们发布生成的 hellok8s helm chart，先将手动生成的 <code>hello-helm-0.1.0.tgz</code> 和 <code>index.yaml</code> 文件删除，后续使用 GitHub action 自动生成和发布这两个文件。</p>
<p>GitHub action 的代码可以参考 <a target="_blank" rel="noopener" href="https://helm.sh/zh/docs/howto/chart_releaser_action/">官网文档</a> 或者本仓库 <code>.github/workflows/release.yml</code> 文件。代表当 push 代码到远程仓库时，将 <code>helm-charts</code> 目录下的所有 charts 自动打包和发布到 <code>gh-pages</code> 分支去(需要保证 <code>gh-pages</code> 分支已经存在，否则会报错)。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Release</span> <span class="hljs-string">Charts</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">release:</span><br>    <span class="hljs-comment"># depending on default permission settings for your org (contents being read-only or read-write for workloads), you will have to add permissions</span><br>    <span class="hljs-comment"># see: https://docs.github.com/en/actions/security-guides/automatic-token-authentication#modifying-the-permissions-for-the-github_token</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">fetch-depth:</span> <span class="hljs-number">0</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">Git</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git config user.name &quot;$GITHUB_ACTOR&quot;</span><br><span class="hljs-string">          git config user.email &quot;$GITHUB_ACTOR@users.noreply.github.com&quot;</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Helm</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">azure/setup-helm@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">version:</span> <span class="hljs-string">v3.8.1</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">chart-releaser</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">helm/chart-releaser-action@v1.4.0</span><br>        <span class="hljs-attr">with:</span> <br>          <span class="hljs-attr">charts_dir:</span> <span class="hljs-string">helm-charts</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">CR_TOKEN:</span> <span class="hljs-string">&quot;$<span class="hljs-template-variable">&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure>

<p>接着配置仓库的 <code>Settings -&gt; Pages -&gt; Build and deployment -&gt; Branch</code>，选择 <code>gh-pages</code> 分支，GitHub 会自动在 <code>https://username.github.io/project</code> 发布 helm chart。</p>
<h1 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h1><h2 id="存活探针-livenessProb"><a href="#存活探针-livenessProb" class="headerlink" title="存活探针 (livenessProb)"></a>存活探针 (livenessProb)</h2><blockquote>
<p>存活探测器来确定什么时候要重启容器。 例如，存活探测器可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。– <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">LivenessProb</a></p>
</blockquote>
<p>在生产中，有时候因为某些 bug 导致应用死锁或者线程耗尽了，最终会导致应用无法继续提供服务，这个时候如果没有手段来自动监控和处理这一问题的话，可能会导致很长一段时间无人发现。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> 使用存活探测器 (livenessProb) 来确定什么时候要重启容器。</p>
<p>接下来我们写一个 <code>/healthz</code> 接口来说明 <code>livenessProb</code> 如何使用。 <code>/healthz</code> 接口会在启动成功的 15s 内正常返回 200 状态码，在 15s 后，会一直返回 500 的状态码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	io.WriteString(w, <span class="hljs-string">&quot;[v2] Hello, Kubernetes!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	started := time.Now()<br>	http.HandleFunc(<span class="hljs-string">&quot;/healthz&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>		duration := time.Since(started)<br>		<span class="hljs-keyword">if</span> duration.Seconds() &gt; <span class="hljs-number">15</span> &#123;<br>			w.WriteHeader(<span class="hljs-number">500</span>)<br>			w.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error: %v&quot;</span>, duration.Seconds())))<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			w.WriteHeader(<span class="hljs-number">200</span>)<br>			w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ok&quot;</span>))<br>		&#125;<br>	&#125;)<br><br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写对应的 <code>Dockerfile</code> 文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Dockerfile</span><br><span class="hljs-string">FROM</span> <span class="hljs-string">golang:1.16-buster</span> <span class="hljs-string">AS</span> <span class="hljs-string">builder</span><br><span class="hljs-string">RUN</span> <span class="hljs-string">mkdir</span> <span class="hljs-string">/src</span><br><span class="hljs-string">ADD</span> <span class="hljs-string">.</span> <span class="hljs-string">/src</span><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/src</span><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">go</span> <span class="hljs-string">env</span> <span class="hljs-string">-w</span> <span class="hljs-string">GO111MODULE=auto</span><br><span class="hljs-string">RUN</span> <span class="hljs-string">go</span> <span class="hljs-string">build</span> <span class="hljs-string">-o</span> <span class="hljs-string">main</span> <span class="hljs-string">.</span><br><br><span class="hljs-string">FROM</span> <span class="hljs-string">gcr.io/distroless/base-debian10</span><br><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/</span><br><br><span class="hljs-string">COPY</span> <span class="hljs-string">--from=builder</span> <span class="hljs-string">/src/main</span> <span class="hljs-string">/main</span><br><span class="hljs-string">EXPOSE</span> <span class="hljs-number">3000</span><br><span class="hljs-string">ENTRYPOINT</span> [<span class="hljs-string">&quot;/main&quot;</span>]<br></code></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 的编写和原来保持一致，我们把 <code>tag</code> 修改为 <code>liveness</code> 并推送到远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t guangzhengli/hellok8s:liveness<br>docker push guangzhengli/hellok8s:liveness<br></code></pre></td></tr></table></figure>

<p>最后编写 deployment 的定义，这里使用存活探测方式是使用 HTTP GET 请求，请求的是刚才定义的 <code>/healthz</code> 接口，<code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。 如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><br>     <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">guangzhengli/hellok8s:liveness</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">livenessProbe:</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">3000</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>通过 <code>get</code> 或者 <code>describe</code> 命令可以发现 pod 一直处于重启当中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f deployment.yaml<br><br>kubectl get pods<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS    RESTARTS     AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5995ff9447-d5fbz   1/1     Running   4 (6s ago)   102s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5995ff9447-gz2cx   1/1     Running   4 (5s ago)   101s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-5995ff9447-rh29x   1/1     Running   4 (6s ago)   102s</span><br><br>kubectl describe pod hellok8s-68f47f657c-zwn6g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Events:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Type     Reason     Age                   From               Message</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> ----     ------     ----                  ----               -------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Normal   Scheduled  12m                   default-scheduler  Successfully assigned default/hellok8s-deployment-5995ff9447-rh29x to minikube</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Normal   Pulled     11m (x4 over 12m)     kubelet            Container image <span class="hljs-string">&quot;guangzhengli/hellok8s:liveness&quot;</span> already present on machine</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Normal   Created    11m (x4 over 12m)     kubelet            Created container hellok8s-container</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Normal   Started    11m (x4 over 12m)     kubelet            Started container hellok8s-container</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Normal   Killing    11m (x3 over 12m)     kubelet            Container hellok8s-container failed liveness probe, will be restarted</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Warning  Unhealthy  11m (x10 over 12m)    kubelet            Liveness probe failed: HTTP probe failed with statuscode: 500</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Warning  BackOff    2m41s (x36 over 10m)  kubelet            Back-off restarting failed container</span><br></code></pre></td></tr></table></figure>

<h2 id="就绪探针-readiness"><a href="#就绪探针-readiness" class="headerlink" title="就绪探针 (readiness)"></a>就绪探针 (readiness)</h2><blockquote>
<p>就绪探测器可以知道容器何时准备好接受请求流量，当一个 Pod 内的所有容器都就绪时，才能认为该 Pod 就绪。 这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。 若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。– <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">ReadinessProb</a></p>
</blockquote>
<p>在生产环境中，升级服务的版本是日常的需求，这时我们需要考虑一种场景，即当发布的版本存在问题，就不应该让它升级成功。kubelet 使用就绪探测器可以知道容器何时准备好接受请求流量，当一个 pod 升级后不能就绪，即不应该让流量进入该 pod，在配合 <code>rollingUpate</code> 的功能下，也不能允许升级版本继续下去，否则服务会出现全部升级完成，导致所有服务均不可用的情况。</p>
<p>这里我们把服务回滚到 <code>hellok8s:v2</code> 的版本，可以通过上面学习的方法进行回滚。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl rollout undo deployment hellok8s-deployment --to-revision=2<br></code></pre></td></tr></table></figure>

<p>这里我们将应用的 <code>/healthz</code> 接口直接设置成返回 500 状态码，代表该版本是一个有问题的版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;io&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>	io.WriteString(w, <span class="hljs-string">&quot;[v2] Hello, Kubernetes!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/healthz&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>			w.WriteHeader(<span class="hljs-number">500</span>)<br>	&#125;)<br><br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>build</code> 阶段我们将 <code>tag</code> 设置为 <code>bad</code>，打包后 push 到远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t guangzhengli/hellok8s:bad<br><br>docker push guangzhengli/hellok8s:bad<br></code></pre></td></tr></table></figure>

<p>接着编写 deployment 资源文件，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core">Probe</a> 有很多配置字段，可以使用这些字段精确地控制就绪检测的行为：</p>
<ul>
<li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动存活和就绪探测器， 默认是 0 秒，最小值是 0。</li>
<li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
<li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code>：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><br>     <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hellok8s</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">guangzhengli/hellok8s:bad</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">hellok8s-container</span><br>          <span class="hljs-attr">readinessProbe:</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">3000</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>通过 <code>get</code> 命令可以发现两个 pod 一直处于还没有 Ready 的状态当中，通过 <code>describe</code> 命令可以看到是因为 <code>Readiness probe failed: HTTP probe failed with statuscode: 500</code> 的原因。又因为设置了最小不可用的服务数量为<code>maxUnavailable=1</code>，这样能保证剩下两个 <code>v2</code> 版本的 <code>hellok8s</code> 能继续提供服务！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f deployment.yaml<br><br>kubectl get pods                <br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-66799848c4-8xzsz   1/1     Running   0          102s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-66799848c4-m9dl5   1/1     Running   0          102s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-9c57c7f56-rww7k    0/1     Running   0          26s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hellok8s-deployment-9c57c7f56-xt9tw    0/1     Running   0          26s</span><br><br><br>kubectl describe pod hellok8s-deployment-9c57c7f56-rww7k<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Events:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Type     Reason     Age                From               Message</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ----     ------     ----               ----               -------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Normal   Scheduled  74s                default-scheduler  Successfully assigned default/hellok8s-deployment-9c57c7f56-rww7k to minikube</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Normal   Pulled     73s                kubelet            Container image <span class="hljs-string">&quot;guangzhengli/hellok8s:bad&quot;</span> already present on machine</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Normal   Created    73s                kubelet            Created container hellok8s-container</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Normal   Started    73s                kubelet            Started container hellok8s-container</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  Warning  Unhealthy  0s (x10 over 72s)  kubelet            Readiness probe failed: HTTP probe fa</span><br></code></pre></td></tr></table></figure>

<h1 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h1><p>2025年4月11日 · 251 字</p>
<h2 id="kubernetes-dashboard"><a href="#kubernetes-dashboard" class="headerlink" title="kubernetes dashboard"></a>kubernetes dashboard</h2><blockquote>
<p>Dashboard 是基于网页的 Kubernetes 用户界面。 你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。 你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment，Job，DaemonSet 等等）。 例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p>
</blockquote>
<p>在本地 minikube 环境，可以直接通过下面命令开启 Dashboard。更多用法可以参考官网或者自行探索。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">minikube dashboard<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/eB3MYd.png" srcset="/img/loading.gif" lazyload alt="eB3MYd"></p>
<h2 id="K9s"><a href="#K9s" class="headerlink" title="K9s"></a>K9s</h2><p><a target="_blank" rel="noopener" href="https://k9scli.io/">K9s</a> 是一个基于 Terminal 的轻量级 UI，可以更加轻松的观察和管理已部署的 k8s 资源。使用方式非常简单，安装后输入 <code>k9s</code> 即可开启 Terminal Dashboard，更多用法可以参考官网。</p>
<p><img src="https://tuyiblog.oss-cn-guangzhou.aliyuncs.com/blog/83ybd4.png" srcset="/img/loading.gif" lazyload alt="83ybd4"></p>
<p>refer</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/">minikube</a></li>
<li><a target="_blank" rel="noopener" href="https://guangzhengli.com/courses">k8s教程</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/k8s/" class="print-no-link">#k8s</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>k8s学习(基于minikube模拟)</div>
      <div>https://tuyiisxp.github.io/2025/04/26/k8s学习(基于minikube模拟)/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>tuyi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月26日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年4月28日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/28/k8s%E5%AD%A6%E4%B9%A0-kubeadm/" title="k8s学习(kubeadm)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">k8s学习(kubeadm)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/26/vmtools%E5%AE%89%E8%A3%85/" title="vmtools安装">
                        <span class="hidden-mobile">vmtools安装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', '258369123/pinglun');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script>
<script src="/js/reward.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
